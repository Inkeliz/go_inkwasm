package parser

import (
	"bytes"
	"fmt"
	"github.com/inkeliz/go_inkwasm/bind"
	"io"
	"strconv"
	"strings"
)

type Mode uint64

const (
	Release Mode = iota
	Test
)

type Binder struct {
	RemapPath func(s string) string
	mode      Mode
	js, asm   writer
	golang    writer
	asmLinker writer
	imports   writer
}

func NewBinder(m Mode) *Binder {
	return &Binder{
		RemapPath: func(s string) string { return s },
		mode:      m,
		js:        writer{Buffer: bytes.NewBuffer(nil)},
		asm:       writer{Buffer: bytes.NewBuffer(nil)},
		golang:    writer{Buffer: bytes.NewBuffer(nil)},
		asmLinker: writer{Buffer: bytes.NewBuffer(nil)},
		imports:   writer{Buffer: bytes.NewBuffer(nil)},
	}
}

func (b *Binder) Create(pkg bind.Package, files []*bind.Function) error {
	importFunctions := make([]*bind.Function, 0, len(files))
	exportFunctions := make([]*bind.Function, 0, len(files))
	for _, f := range files {
		if f.IsTest == (b.mode == Test) {
			if f.Hint != bind.HintExport {
				importFunctions = append(importFunctions, f)
			} else {
				exportFunctions = append(exportFunctions, f)
			}
		}
	}

	if len(importFunctions)+len(exportFunctions) == 0 {
		return nil
	}

	if err := b.createExport(pkg, exportFunctions); err != nil {
		return err
	}

	if err := b.createImports(pkg, importFunctions); err != nil {
		return err
	}

	return nil
}

func (b *Binder) createExport(pkg bind.Package, files []*bind.Function) error {
	if err := b.createExportJavascript(pkg, files); err != nil {
		return err
	}

	return nil
}

func (b *Binder) createImports(pkg bind.Package, files []*bind.Function) error {
	if err := b.createGolang(pkg, files); err != nil {
		return err
	}

	if err := b.createAssembly(pkg, files); err != nil {
		return err
	}

	if err := b.createJavascript(pkg, files); err != nil {
		return err
	}

	return nil
}

func (b *Binder) JS() io.Reader {
	return b.js
}

func (b *Binder) ASM() io.Reader {
	return b.asm
}

func (b *Binder) GO() io.Reader {
	return b.golang
}

func (b *Binder) headerAssembly() {
	if b.asm.Len() > 0 {
		return
	}
	b.asm.Write(`// Code generated by INKWASM BUILD; DO NOT EDIT`)
	b.asm.Line()
	b.asm.Write(`#include "textflag.h"`)
	b.asm.Line()
}

func (b *Binder) createAssembly(_ bind.Package, info []*bind.Function) error {
	b.headerAssembly()

	for _, info := range info {
		b.asm.Line()
		b.asm.WriteOpen(`TEXT ·__%s(SB), NOSPLIT, $0`, info.FunctionGolang.Name)
		b.asm.Line()
		b.asm.Write(`CallImport`)
		b.asm.Line()
		b.asm.Write(`RET`)
		b.asm.WriteClose("")
		b.asm.Line()
		b.asm.Line()
		b.asm.WriteOpen(`TEXT ·%s(SB), NOSPLIT, $0`, info.FunctionGolang.Name)
		b.asm.Line()
		b.asm.Write(`JMP ·_%s(SB)`, info.FunctionGolang.Name)
		b.asm.Line()
		b.asm.Write(`RET`)
		b.asm.WriteClose("")
		b.asm.Line()
	}

	return nil
}

func (b *Binder) headerGolang(pkg bind.Package, info []*bind.Function) {
	if b.golang.Len() > 0 {
		return
	}
	b.golang.Write(`// Code generated by INKWASM BUILD; DO NOT EDIT`)
	b.golang.Line()
	b.golang.Line()
	b.golang.Write("package %s", pkg.Name)
	b.golang.Line()
	b.golang.Line()
	b.golang.WriteOpen("import (")
	b.golang.Line()
	b.golang.Write(`"runtime"`)
	b.golang.Line()
	if pkg.Path != "github.com/inkeliz/go_inkwasm/inkwasm" {
		b.golang.Write(`"%s"`, "github.com/inkeliz/go_inkwasm/inkwasm")
		b.golang.Line()
	}
	b.golang.WriteClose(")")
	b.golang.Line()
}

func (b *Binder) createGolang(pkg bind.Package, info []*bind.Function) error {
	b.headerGolang(pkg, info)

	for _, info := range info {
		b.golang.Line()

		params := []struct {
			ArgsString     *strings.Builder
			StubArgsString *strings.Builder
			ValString      *strings.Builder
			Args           []bind.Argument
		}{
			{ArgsString: new(strings.Builder), ValString: new(strings.Builder), StubArgsString: new(strings.Builder), Args: info.Arguments},
			{ArgsString: new(strings.Builder), ValString: new(strings.Builder), StubArgsString: new(strings.Builder), Args: info.Result},
		}

		var (
			keepAlive    []string
			decoder      string
			unsafeConv   string
			unsafeResize int
		)
		for d, p := range params {
			p := p
			for i, arg := range p.Args {
				if arg.Type == "inkwasm.Object" && pkg.Path == "github.com/inkeliz/go_inkwasm/inkwasm" {
					arg.Type = "Object"
				}
				if arg.Name == "" || arg.Name == "_" {
					if d == 0 {
						arg.Name = "p" + strconv.Itoa(i)
					} else {
						arg.Name = "_"
					}
				}
				switch arg.ArgType {
				case bind.ModeStatic:
					p.ArgsString.WriteString(fmt.Sprintf("%s %s", arg.Name, arg.Type))
					if arg.Type == "string" {
						// JS function must use Object
						obj := "inkwasm.Object"
						if pkg.Path == "github.com/inkeliz/go_inkwasm/inkwasm" {
							obj = "Object"
						}
						p.StubArgsString.WriteString(fmt.Sprintf("%s %s", arg.Name, obj))
						if d == 0 {
							keepAlive = append(keepAlive, arg.Name)
						}
						if d == 1 {
							decoder = ".MustString()"
						}
					} else {
						p.StubArgsString.WriteString(fmt.Sprintf("%s %s", arg.Name, arg.Type))
					}
				case bind.ModePointer:
					p.ArgsString.WriteString(fmt.Sprintf("%s *%s", arg.Name, arg.SubType.Type))
					p.StubArgsString.WriteString(fmt.Sprintf("%s *%s", arg.Name, arg.Type))
					if d == 0 {
						keepAlive = append(keepAlive, arg.Name)
					}
				case bind.ModeArray:
					p.ArgsString.WriteString(fmt.Sprintf("%s [%d]%s", arg.Name, arg.Len, arg.SubType.Type))
					p.StubArgsString.WriteString(fmt.Sprintf("%s [%d]%s", arg.Name, arg.Len, arg.SubType.Type))
					if d == 0 {
						keepAlive = append(keepAlive, arg.Name)
					}
				case bind.ModeSlice:
					p.ArgsString.WriteString(fmt.Sprintf("%s []%s", arg.Name, arg.SubType.Type))
					// JS function must use Object
					obj := "inkwasm.Object"
					if pkg.Path == "github.com/inkeliz/go_inkwasm/inkwasm" {
						obj = "Object"
					}
					p.StubArgsString.WriteString(fmt.Sprintf("%s %s", arg.Name, obj))
					if d == 1 {
						decoder = ".MustBytes(nil)"
						t := bind.ResultFunc[bind.ModeArray][arg.SubType.Type]
						unsafeConv = fmt.Sprintf("[]%s", arg.SubType.Type)
						if t.Size != 1 {
							unsafeResize = t.Size
						}
					}
					if d == 0 {
						keepAlive = append(keepAlive, arg.Name)
					}
				}

				p.ValString.WriteString(arg.Name)
				if i != len(p.Args)-1 {
					p.StubArgsString.WriteString(", ")
					p.ArgsString.WriteString(", ")
					p.ValString.WriteString(", ")
				}
			}
		}
		b.golang.Line()
		b.golang.WriteOpen("func _%s(%s) (%s) {", info.FunctionGolang.Name, params[0].ArgsString.String(), params[1].ArgsString.String())
		b.golang.Line()
		if len(info.FunctionGolang.Result) == 1 {
			b.golang.Write(`r0 :=`)
		}
		if len(info.FunctionGolang.Result) == 2 {
			b.golang.Write(`r0, r1 :=`)
		}
		b.golang.Write(`__%s(%s)`, info.FunctionGolang.Name, params[0].ValString.String())
		b.golang.Line()
		for _, a := range keepAlive {
			b.golang.Write(`runtime.KeepAlive(%s)`, a)
			b.golang.Line()
		}
		var resultVar = "r0"
		if decoder != "" {
			resultVar = "rx"
			b.golang.Write(`%s := r0%s`, resultVar, decoder)
			b.golang.Line()
			b.golang.Write(`r0.Free()`)
		}
		if unsafeResize > 1 {
			b.golang.Line()
			b.golang.Write(`(*[3]int)(unsafe.Pointer(&rx))[1] = %d`, unsafeResize)
			b.golang.Write(`(*[3]int)(unsafe.Pointer(&rx))[2] = %d`, unsafeResize)
		}
		if unsafeConv != "" {
			resultVar = fmt.Sprintf(`*(*%s)(unsafe.Pointer(&rx))`, unsafeConv)
		}
		b.golang.Line()
		if len(info.FunctionGolang.Result) == 1 {
			b.golang.Write(`return %s`, resultVar)
		}
		if len(info.FunctionGolang.Result) == 2 {
			b.golang.Write(`return %s, r1`, resultVar)
		}
		b.golang.Line()
		b.golang.WriteClose("}")
		b.golang.Line()
		b.golang.Write("func __%s(%s) (%s)", info.FunctionGolang.Name, params[0].ArgsString.String(), params[1].StubArgsString.String())
		b.golang.Line()
	}

	return nil
}

func (b *Binder) createExportJavascript(pkg bind.Package, info []*bind.Function) error {
	b.js.Write(`// Code generated by INKWASM BUILD; DO NOT EDIT`)
	b.js.Line()
	b.js.WriteOpen(`(() => {`)
	b.js.Line()

	for _, info := range info {
		decoderName := fmt.Sprintf(`globalThis.inkwasm.Load.%s`, info.FunctionGolang.Name)

		b.js.Line()
		b.js.WriteOpen(`%s = function(go, sp, offset) {`, decoderName)
		b.js.Line()
		b.js.Write(`sp += offset`)
		b.js.Line()
		b.js.WriteOpen(`return {`)
		b.js.Line()

		var sp = 0

		for _, r := range info.Arguments {
			name := r.Name
			if r.Tag != "" {
				name = r.Tag
			}
			b.js.Write(`"%s":`, name)
			if err := writeGoToJS(&b.js, r, &sp); err != nil {
				return info.CreateError(err.Error())
			}
			b.js.WriteInline(",")
			b.js.Line()
		}

		size := sp
		if left := size % 4; left != 0 {
			size += 4 - left
		}

		bind.BridgeFunc[bind.ModeStatic][strings.ToLower(info.FunctionGolang.Name)] = bind.BridgeFuncInfo{
			JS:   decoderName,
			Size: size,
		}

		b.js.Line()
		b.js.WriteClose(`}`)
		b.js.Line()
		b.js.WriteClose(`}`)
		b.js.Line()
	}

	b.js.Line()
	b.js.WriteClose(`})();`)
	b.js.Line()

	return nil
}

func (b *Binder) createJavascript(pkg bind.Package, info []*bind.Function) error {
	b.js.Write(`// Code generated by INKWASM BUILD; DO NOT EDIT`)
	b.js.Line()
	b.js.WriteOpen(`(() => {`)
	b.js.Line()
	b.js.WriteOpen(`Object.assign(go.importObject.go, {`)
	b.js.Line()

	path := pkg.Path
	if pkg.Name == "main" {
		path = "main"
	}

	for _, info := range info {
		b.js.Line()
		b.js.WriteOpen(`"%s.__%s": (sp) => {`, path, info.FunctionGolang.Name)
		b.js.Line()

		var (
			sp                                 = 8
			resultHolder                       = ""
			functionInjection                  = ""
			functionExecStart, functionExecEnd = "", ""
		)

		if strings.HasPrefix(info.FunctionJavascript.Name, ".") {
			if len(info.FunctionGolang.Arguments) == 0 || !strings.EqualFold(info.FunctionGolang.Arguments[0].Type, "inkwasm.object") {
				return info.CreateError("the first argument must be inkwasm.Object, since it starts with dot (%s)", info.FunctionJavascript.Name)
			}
			f := bind.BridgeFunc[bind.ModeStatic]["inkwasm.object"]
			functionInjection = fmt.Sprintf("%s(go, sp, %d)", f.JS, sp)
			sp += f.Size
			info.FunctionGolang.Arguments = info.FunctionGolang.Arguments[1:]
		}

		if info.FunctionJavascript.Name == "." {
			info.FunctionJavascript.Name = ""
		}

		switch info.FunctionJavascript.Hint {
		case bind.HintGet:
			if len(info.FunctionGolang.Arguments) > 1 {
				return info.CreateError("invalid usage of %s. Function can't have more than one argument", info.FunctionJavascript.Hint)
			}
			if len(info.FunctionGolang.Arguments) > 0 {
				functionExecStart, functionExecEnd = "[", "]"
			}
			resultHolder = "let r = "
		case bind.HintFunc:
			if len(info.FunctionGolang.Result) > 0 {
				resultHolder = "let r = "
			}
			functionExecStart, functionExecEnd = "(", ")"
		case bind.HintNew:
			resultHolder = "let r = new "
			functionExecStart, functionExecEnd = "(", ")"
		case bind.HintSet:
			if len(info.FunctionGolang.Arguments) != 1 {
				return info.CreateError("invalid usage of %s. Function must have one argument.", info.FunctionJavascript.Hint)
			}
			if len(info.FunctionGolang.Result) > 0 {
				return info.CreateError("invalid usage of %s. Set can have results.", info.FunctionJavascript.Hint)
			}
			functionExecStart, functionExecEnd = " = ", ""
		default:
			return info.CreateError("unknown hint of '%s'. The comment must be //inkwasm:{hint}, where {hint} can be either 'func', 'get', 'set', 'new'.", info.FunctionJavascript.Hint)
		}

		if len(info.Result) > 2 {
			return info.CreateError("function can only have a maximum of 2 results, currently having %d.", len(info.Result))
		}
		if len(info.Result) == 2 && info.Result[1].Type != "bool" {
			return info.CreateError("when two results is provided, the last result of the function must be 'bool'")
		}

		if len(info.Result) == 2 {
			b.js.WriteOpen("try {")
			b.js.Line()
		}

		b.js.Write("%s%s%s%s", resultHolder, functionInjection, info.FunctionJavascript.Name, functionExecStart)

		last := len(info.Arguments) - 1
		for i, r := range info.Arguments {
			if err := writeGoToJS(&b.js, r, &sp); err != nil {
				return info.CreateError(err.Error())
			}
			if last != i {
				b.js.WriteInline(",")
			}
		}
		b.js.WriteInline(functionExecEnd)
		b.js.Line()

		padding(&sp, sp)

		if len(info.Result) > 0 {
			b.js.Write(`sp = go._inst.exports.getsp() >>> 0`)
			b.js.Line()
			if err := writeJSToGo(&b.js, info.Result[0], &sp, "r"); err != nil {
				return info.CreateError(err.Error())
			}
			if len(info.Result) > 1 {
				b.js.Line()
				if err := writeJSToGo(&b.js, info.Result[1], &sp, "true"); err != nil {
					return info.CreateError(err.Error())
				}
			}
		}

		if len(info.Result) == 2 {
			b.js.Line()
			b.js.WriteClose("")
			b.js.WriteOpen("}catch(e){")
			b.js.Line()
			b.js.Write("console.log(e)")
			b.js.Line()
			sp -= 1
			if err := writeJSToGo(&b.js, info.Result[1], &sp, "false"); err != nil {
				return info.CreateError(err.Error())
			}
			b.js.Line()
			b.js.WriteClose("}")
		}

		b.js.Line()
		b.js.WriteClose(`},`)
		b.js.Line()
	}
	b.js.Line()
	b.js.WriteClose(`})`)
	b.js.Line()
	b.js.WriteClose(`})();`)
	b.js.Line()

	return nil
}

func padding(sp *int, l int) {
	if l > 8 {
		l = 8
	}
	if ((*sp % 8) % l) > 0 {
		*sp += l - ((*sp % 8) % l)
	}
}

func writeGoToJS(w *writer, r bind.Argument, sp *int) error {
	switch r.ArgType {
	case bind.ModeStatic:
		f, ok := bind.BridgeFunc[bind.ModeStatic][strings.ToLower(r.Type)]
		if !ok {
			return fmt.Errorf("invalid type of %s", r.Type)
		}
		padding(sp, f.Size)
		w.WriteInline(`%s(go, sp, %d)`, f.JS, *sp)
		*sp += f.Size
	case bind.ModeArray:
		array, _ := bind.BridgeFunc[r.ArgType]["default"]
		f, ok := bind.BridgeFunc[bind.ModeArray][strings.ToLower(r.SubType.Type)]
		if !ok {
			return fmt.Errorf("invalid type of array %s", r.Type)
		}
		padding(sp, f.Size)
		w.WriteInline(`%s(go, sp, %d, %d, %s)`, array.JS, *sp, r.Len, f.JS)
		*sp += int(r.Len) * f.Size
	case bind.ModeSlice:
		slice, _ := bind.BridgeFunc[r.ArgType]["default"]
		padding(sp, slice.Size)
		f, ok := bind.BridgeFunc[bind.ModeArray][strings.ToLower(r.SubType.Type)]
		if !ok {
			return fmt.Errorf("invalid type of slice %s", r.Type)
		}
		w.WriteInline(`%s(go, sp, %d, %s)`, slice.JS, *sp, f.JS)
		*sp += slice.Size
	case bind.ModePointer:
		ptr, _ := bind.BridgeFunc[r.ArgType]["default"]
		padding(sp, ptr.Size)
		f, ok := bind.BridgeFunc[r.SubType.ArgType][strings.ToLower(r.SubType.Type)]
		if !ok {
			return fmt.Errorf("invalid type of pointer %s", r.Type)
		}
		w.WriteInline(`%s(go, sp, %d, %s)`, ptr.JS, *sp, f.JS)
		*sp += ptr.Size
	}

	return nil
}

func writeJSToGo(w *writer, r bind.Argument, sp *int, v string) error {
	switch r.ArgType {
	case bind.ModeStatic:
		f, ok := bind.ResultFunc[bind.ModeStatic][strings.ToLower(r.Type)]
		if !ok {
			return fmt.Errorf("invalid type of %s", r.Type)
		}
		padding(sp, f.Size)
		w.Write(`%s(go, sp, %d, %s)`, f.JS, *sp, v)
		*sp += f.Size
	case bind.ModeArray:
		array, _ := bind.ResultFunc[r.ArgType]["default"]
		f, ok := bind.ResultFunc[bind.ModeArray][strings.ToLower(r.SubType.Type)]
		if !ok {
			return fmt.Errorf("invalid type of slice %s", r.Type)
		}
		padding(sp, f.Size)
		w.Write(`%s(go, sp, %d, %s, %d, %d, %s)`, array.JS, *sp, v, r.Len, f.Size, f.JS)
		*sp += int(r.Len) * f.Size
	case bind.ModeSlice:
		slice, _ := bind.ResultFunc[r.ArgType]["default"]
		padding(sp, slice.Size)
		f, ok := bind.BridgeFunc[bind.ModeArray][strings.ToLower(r.SubType.Type)]
		if !ok {
			return fmt.Errorf("invalid type of slice %s", r.Type)
		}
		w.Write(`%s(go, sp, %d, %s, %d)`, slice.JS, *sp, v, f.Size)
		*sp += slice.Size
	default:
		return fmt.Errorf("unsupported result type of %s", r.Type)
	}

	return nil
}

type writer struct {
	*bytes.Buffer
	t string
	i int
}

func (w *writer) WriteOpen(s string, i ...interface{}) {
	w.Write(s, i...)
	w.i++
	w.t = strings.Repeat("\t", w.i)
}

func (w writer) Write(s string, i ...interface{}) {
	fmt.Fprintf(w.Buffer, w.t+s, i...)
}

func (w writer) WriteInline(s string, i ...interface{}) {
	fmt.Fprintf(w.Buffer, s, i...)
}

func (w *writer) WriteClose(s string, i ...interface{}) {
	w.i--
	w.t = strings.Repeat("\t", w.i)
	w.Write(s, i...)
}

func (w writer) Line() {
	w.Buffer.Write([]byte("\n"))
}
